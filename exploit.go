package main

import (
	"bufio"
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"regexp"
	"strconv"
	"strings"
	"syscall"
	"time"
)

var flagOutfile = flag.String("outfile", "", "output file")
var flagOutfileBE = flag.String("outfile_be", "", "output file (big endian)")
var flagStart = flag.Uint("start", 0xc0000000, "start address")
var flagLen = flag.Uint("length", 1024, "length in bytes")

var debug = log.New(os.Stderr, "DEBUG: ", log.LstdFlags)
var warning = log.New(os.Stderr, "WARNING: ", log.LstdFlags)

func init() {
	log.SetOutput(os.Stderr)
}

func wait(cmd *exec.Cmd) error {
	err := cmd.Wait()
	if err == nil {
		return nil
	}

	ee, ok := err.(*exec.ExitError)
	if !ok {
		return err
	}

	ws, ok := ee.ProcessState.Sys().(syscall.WaitStatus)
	if !ok {
		return err
	}

	if !ws.Signaled() || ws.Signal() != os.Kill {
		return err
	}

	debug.Printf("Ignoring wait error %#v because WaitStatus=%#v indicates we killed it", err, ws)
	return nil
}

type logcatResult struct {
	line string
	err  error
}

func logcat(kill chan struct{}) (<-chan logcatResult, error) {
	cmd := exec.Command("logcat", "-s", "MTK_KL")
	cmd.Stdin = nil
	cmd.Stderr = os.Stderr
	pipe, err := cmd.StdoutPipe()
	if err != nil {
		return nil, fmt.Errorf("can't get a pipe to stdout: %v", err)
	}

	if err := cmd.Start(); err != nil {
		return nil, fmt.Errorf("can't start logcat: %v", err)
	}

	go func() {
		<-kill
		debug.Printf("Killing logcat %#v", cmd.Process)
		cmd.Process.Kill()
	}()

	ret := make(chan logcatResult, 1)
	go func() {
		defer close(ret)

		s := bufio.NewScanner(pipe)
		for s.Scan() {
			line := strings.Replace(s.Text(), "\r", "", -1)
			ret <- logcatResult{line: line}
		}

		if err := s.Err(); err != nil {
			ret <- logcatResult{err: fmt.Errorf("while scanning logcat: %v", err)}
			close(kill)
		}

		if err := wait(cmd); err != nil {
			ret <- logcatResult{err: fmt.Errorf("while waiting for logcat: %v", err)}
		}
	}()

	return ret, nil
}

type addr uint32
type word uint32

// region is a consecutive region of memory.
type region struct {
	base addr
	mem  []word
}

func (r *region) String() string {
	const thresh = 8
	words := ""
	if len(r.mem) <= thresh {
		words = fmt.Sprintf("%08x", r.mem)
	} else {
		first := fmt.Sprintf("%08x", r.mem[0:thresh/2])
		first = first[:len(first)-1] // cut “]”

		second := fmt.Sprintf("%08x", r.mem[len(r.mem)-thresh/2:])
		second = second[1:] // cut “[”

		words = fmt.Sprintf("%s … %d more words … %s", first, len(r.mem)-thresh, second)
	}

	return fmt.Sprintf("&region{base=0x%08x, mem=%d words: %s}", r.base, len(r.mem), words)
}

type errOutOfRange struct {
	a, base, next addr
}

func (e *errOutOfRange) Error() string {
	return fmt.Sprintf("out of range: a=0x%08x < base=0x%08x or > next=0x%08x", e.a, e.base, e.next)
}

// add adds a list of words to a region.
func (r *region) add(a addr, mem []word) error {
	if a%4 != 0 {
		return fmt.Errorf("%08x is not on a word boundary", a)
	}

	if r.base == 0 {
		r.base = a
	}

	if bs, be := r.bounds(); a < bs || a > be+4 {
		return &errOutOfRange{a: a, base: bs, next: be + 4}
	}

	idx := int(a-r.base) / 4
	for idx < len(r.mem) && len(mem) > 0 {
		if r.mem[idx] != mem[0] {
			return fmt.Errorf("inconsistent word at 0x%08x: %08x (now) vs. %08x (previous)", r.base+addr(idx*4), r.mem[idx], mem[0])
		}
		mem = mem[1:]
		idx++
	}

	if len(mem) > 0 {
		r.mem = append(r.mem, mem...)
	}

	return nil
}

func (r *region) bounds() (addr, addr) {
	return r.base, r.base + addr(len(r.mem)*4)
}

func (r *region) slice(start, end addr) []word {
	if start%4 != 0 || end%4 != 0 {
		log.Panicf("slice(%08x, %08x): not on a word boundary", start, end)
	}

	if s, e := r.bounds(); start < s || end > e {
		return nil
	}

	si := int(start-r.base) / 4
	ei := int(end-r.base) / 4
	return r.mem[si:ei]
}

type cli interface {
	sendAsync(string) error
}

type adbCli struct{}

func (c *adbCli) sendAsync(command string) error {
	cmd := exec.Command("adb", "shell", "cli_shell", command)
	if err := cmd.Start(); err != nil {
		return err
	}

	go func() {
		if err := cmd.Wait(); err != nil {
			warning.Printf("cli_shell failed: %v", err)
		}
	}()
	return nil
}

// memRE matches a kernel log line printed by “r". Example:
// <4>[15831.272092] 0xC0008000 | E10F9000 E229901A E319001F E3C9901F
// <4>[15831.272092] 0xC0008010 | E38990D3 1A000004 E3899C01 E28FE00C"
var memRE = regexp.MustCompile(`\] 0x([[:xdigit:]]{8}) \|((?:\s+[[:xdigit:]]{8})+)\s*$`)

// mustAtoi converts a string to a uint32. It crashes if ParseUint fails, because
// memRE should never return an invalid number.
func mustAtoi(s string) uint32 {
	v, err := strconv.ParseUint(s, 16, 32)
	if err != nil {
		log.Panicf("ParseUint(%q, 16, 32) unexpectedly failed: %v", s, err)
	}
	return uint32(v)
}

func getMem(c cli, lc <-chan logcatResult, start addr, nbytes uint) ([]word, error) {
	start &= ^addr(3)
	nbytes &= ^uint(3)

	const atOnce = addr(4 * 4 * 12) // 4 bytes per word, 4 words per line, 4 lines

	r := &region{base: start}

	pos := start
	endpos := start + addr(nbytes)

	send := time.NewTicker(750 * time.Millisecond)
	defer send.Stop()

	ttfw := time.Now().Add(15 * time.Second)

	last := addr(0)
	n := 0

	sendRead := func(pos addr) {
		err := c.sendAsync(fmt.Sprintf("r 0x%08x %d", pos, atOnce))
		if err != nil {
			warning.Printf("Unable to issue read request for %d bytes at 0x%08x: %v", atOnce, pos, err)
		} else {
			debug.Printf("Issued read request for %d bytes at 0x%08x", atOnce, pos)
		}
	}

	sendRead(pos)
F:
	for {
		select {
		case <-send.C:
			debug.Printf("tick")

			if last == addr(0) && len(r.mem) == 0 {
				if time.Now().After(ttfw) {
					return nil, fmt.Errorf("timed out waiting for first word")
				}
				debug.Printf("Still waiting for first word (until %v)", ttfw)
				sendRead(pos)
				continue F
			}

			if pos == last {
				n++
				if n > 3 {
					return nil, fmt.Errorf("numer of retries for reading %d bytes at 0x%08x exceeded", atOnce, pos)
				}
			} else {
				last = pos
				n = 0
			}

			sendRead(pos)

		case res := <-lc:
			if res.err != nil {
				return nil, fmt.Errorf("while reading from logcat: %v", res.err)
			}

			debug.Printf("got a line: %q", res.line)

			if sm := memRE.FindStringSubmatch(res.line); sm != nil {
				a := addr(mustAtoi(sm[1]))
				ws := make([]word, 0, 4)
				for _, w := range strings.Fields(sm[2]) {
					ws = append(ws, word(mustAtoi(w)))
				}
				if err := r.add(a, ws); err != nil {
					errstr := fmt.Sprintf("can't add %d words (%08x) at 0x%08x to region %v: %v", len(ws), ws, a, r, err)
					if _, ok := err.(*errOutOfRange); ok {
						warning.Print(errstr + " (ignored)")
						continue F
					}
					return nil, errors.New(errstr)
				}

				debug.Printf("Registered %d words at %v", len(ws), r)

				rstart, rend := r.bounds()
				if rend >= pos+atOnce {
					debug.Printf("Region currently ends at %08x, advancing pos by %d bytes", rend, atOnce)
					pos += atOnce
				}

				if rend >= endpos {
					debug.Printf("Region covers requested range (region: %08x-%08x, want: %08x-%08x), returning %d words", rstart, rend, start, endpos, len(r.mem))
					return r.slice(start, endpos), nil
				}
			}
		} //select
	}

	return nil, fmt.Errorf("should not be here")
}

func main() {
	flag.Parse()

	if *flagOutfile == "" {
		log.Fatalf("-outfile is mandatory")
	}
	outf, err := os.Create(*flagOutfile)
	if err != nil {
		log.Fatalf("can't create %q: %v", *flagOutfile, err)
	}
	defer func() {
		if err := outf.Close(); err != nil {
			log.Fatalf("can't close %q: %v", *flagOutfile, err)
		}
	}()

	var bef *os.File
	if *flagOutfileBE != "" {
		var err error
		bef, err = os.Create(*flagOutfileBE)
		if err != nil {
			log.Fatalf("can't create %q: %v", *flagOutfileBE, err)
		}
		defer func() {
			if err := bef.Close(); err != nil {
				log.Fatalf("can't close %q: %v", *flagOutfileBE, err)
			}
		}()
	}

	lcDone := make(chan struct{})
	lc, err := logcat(lcDone)
	if err != nil {
		log.Fatalf("can't stream logcat: %v")
	}
	defer close(lcDone)

	c := &adbCli{}

	mem, err := getMem(c, lc, addr(*flagStart), *flagLen)
	if err != nil {
		log.Fatalf("can't read memory: %v", err)
	}

	log.Printf("mem: len=%d, %08x", len(mem), mem)

	for _, w := range mem {
		bytes := []byte{byte(w >> 24), byte(w >> 16), byte(w >> 8), byte(w)}
		if _, err := outf.Write(bytes); err != nil {
			log.Fatalf("can't write to %q: %v", *flagOutfile, err)
		}

		if bef != nil {
			bytes[0], bytes[1], bytes[2], bytes[3] = bytes[3], bytes[2], bytes[1], bytes[0]
			if _, err := bef.Write(bytes); err != nil {
				log.Fatalf("can't write to %q: %v", *flagOutfileBE, err)
			}
		}
	}
}
